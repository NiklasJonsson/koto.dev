# An implementation of the classic Boids algorithm
# https://en.wikipedia.org/wiki/Boids

import color
from geometry import vec2
from number import lerp, pi, pi_2, tau

boid_count = 20

boid_width = 25
boid_height = 33
visual_range = boid_width * 3
boundary = 20

background_color = color 0.3, 0.3, 0.3

show_ranges = false
visual_range_color = color 0.6, 0.6, 0.6

attraction_factor = 0.01
matching_factor = 0.025
avoidance_factor = 3
boundary_turn_rate = 8
minimum_distance = boid_width * 1.2

initial_speed = 4
speed_limit = 6

make_boid = ||
  x = random.number() * canvas.width()
  y = random.number() * canvas.height()
  direction = random.number() * tau
  c = lerp 0.4, 0.8, random.number()
  return
    color: color c, c, c
    position: vec2 x, y
    velocity: vec2 direction.cos() * initial_speed, direction.sin() * initial_speed

update_boid = |boid, state, time_delta|
  boids_in_range = 1
  position = vec2 boid.position
  other_positions_sum = vec2 position
  other_velocities_sum = vec2 boid.velocity
  avoid_close_boids = vec2 0, 0

  for other_boid in state.boids
    if boid != other_boid
      other_position = other_boid.position
      distance = (position - other_position).length()
      if distance < visual_range
        boids_in_range += 1
        other_positions_sum += other_position
        other_velocities_sum += other_boid.velocity
        if distance < minimum_distance
          avoid_close_boids += position - other_position

  if boids_in_range > 1
    center = other_positions_sum / boids_in_range
    mean_velocity = other_velocities_sum / boids_in_range
    boid.velocity +=
      ((center - position) * attraction_factor
        + (mean_velocity - boid.velocity) * matching_factor
        + avoid_close_boids * avoidance_factor)
      * time_delta

    # Apply speed limit
    speed = boid.velocity.length()
    if speed > speed_limit
      boid.velocity *= speed_limit / speed

  boid.position += boid.velocity

  # Keep in bounds
  x, y = boid.position
  dx, dy = 0, 0
  switch
    x < boundary then dx = initial_speed
    x > canvas.width() - boundary then dx = -initial_speed
  switch
    y < boundary then dy = initial_speed
    y > canvas.height() - boundary then dy = -initial_speed
  boid.velocity += vec2(dx, dy) * boundary_turn_rate * time_delta

draw_boid = |boid|
  xy = boid.position
  x, y = xy

  # Rotate the canvas transformation to match the boid's angle
  canvas
    .translate xy
    .rotate boid.velocity.angle() + pi_2
    .translate -xy

  w2 = boid_width / 2
  bottom = y + boid_height / 3
  top = bottom - boid_height
  bump = bottom - boid_height / 6

  canvas
    .begin_path()
    .move_to x - w2, bottom
    .line_to x, top
    .line_to x + w2, bottom
    .line_to x, bump
    .line_to x - w2, bottom
    .set_fill_color boid.color
    .fill()

  # Reset the canvas transformation
  canvas.set_transform 1, 0, 0, 1, 0, 0

  if show_ranges
    canvas
      .begin_path()
      .arc xy, visual_range, 0, tau
      .move_to x + minimum_distance, y
      .arc xy, minimum_distance, 0, tau
      .set_stroke_color visual_range_color
      .stroke()

export
  setup: ||
    play.show_canvas()

    return
      boids:
        iterator
          .generate boid_count, make_boid
          .to_list()
      last_time: 0

  on_load: |state|
    state.boids.resize_with boid_count, make_boid

  update: |state, time|
    time_delta = time - state.last_time
    state.last_time = time

    canvas.clear background_color

    for boid in state.boids
      update_boid boid, state, time_delta
    for boid in state.boids
      draw_boid boid
